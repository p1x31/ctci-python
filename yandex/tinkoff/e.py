
#right
# Функция для нахождения количества штатов при заданном x
def count_states(x):
    # Создаем множество для хранения посещенных городов
    visited = set()
    # Создаем счетчик для хранения количества штатов
    states = 0
    # Проходим по всем городам
    for i in range(1, n + 1):
        # Если город не посещен, то он принадлежит новому штату
        if i not in visited:
            states += 1
            # Запускаем обход в глубину из этого города
            dfs(i, x, visited)
    # Возвращаем количество штатов
    return states

# Функция для обхода в глубину из заданного города
def dfs(v, x, visited):
    # Помечаем город как посещенный
    visited.add(v)
    # Проходим по всем соседним городам
    for u, w in graph[v]:
        # Если длина дороги не превышает x и город не посещен, то продолжаем обход
        if w > x and u not in visited:
            dfs(u, x, visited)

# Считываем входные данные
n, m = map(int, input().split())
# Создаем словарь для хранения графа
graph = {}
# Проходим по всем дорогам
for _ in range(m):
    v, u, w = map(int, input().split())
    # Добавляем дорогу в обе стороны в граф
    graph.setdefault(v, []).append((u, w))
    graph.setdefault(u, []).append((v, w))

# Находим изначальное количество штатов
initial_states = count_states(0)
# Инициализируем левую и правую границы бинарного поиска
left = 0
right = 10**9 + 1
# Пока левая граница меньше правой
while left < right:
    # Находим середину интервала
    mid = (left + right) // 2
    # Находим количество штатов при этом x
    current_states = count_states(mid)
    # Если количество штатов не изменилось, то увеличиваем левую границу
    if current_states == initial_states:
        left = mid + 1
    # Иначе уменьшаем правую границу
    else:
        right = mid

# Выводим ответ - левая граница минус один
print(left - 1)